extends c

snippet cf Codeforces
    #include <bits/stdc++.h>
    #define all(a) a.begin(), a.end()
    #define sz(a) (int)a.size()
    #define rep(i, a, b) for (int i = a; i < b; ++i)

    constexpr char nl = '\n';
    using namespace std;
    using ll = long long;
    using pii = pair<int, int>;

    template <typename T>
    istream& operator>>(istream &is, vector<T> &v) {
        for (auto& x : v) {
            is >> x;
        }
        return is;
    }

    template <typename T>
    ostream& operator<<(ostream &os, vector<T> &v) {
        for (int i = 0; auto &x : v) {
            os << (i++ ? " " : "") << x;
        }
        os << nl;
    }

    void solve() {
        $0
    }

    int main() {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        int t = 1;
        ${1:cin >> t;}
        while (t--) {
            solve();
        }
    }

snippet ordset GNU PBDS Order Statistic Tree
    #include <ext/pb_ds/assoc_container.hpp>
    using namespace __gnu_pbds;

    template <class T>
    using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

snippet dsu Disjoint Set Union
    class DSU {
        vector<int> parent, setSize;

    public:
        DSU(int n) : parent(n), setSize(n, 1) {
            iota(parent.begin(), parent.end(), 0);
        }

        int findSet(int x) {
            if (parent[x] == x) return x;
            return parent[x] = findSet(parent[x]);
        }

        bool unionSet(int x, int y) {
            int parX = findSet(x), parY = findSet(y);
            if (parX == parY) return false;
            if (setSize[x] < setSize[y]) {
                parent[parX] = parY;
                setSize[parY] += setSize[parX];
            } else {
                parent[parY] = parX;
                setSize[parX] += setSize[parY];
            }
            return true;
        }
    };

snippet dinics Dinics Algorithm (Max Flow)
    class Dinics {
      private:
        struct Edge {
            int v, flow, cap, rev;
        };
        vector<vector<Edge>> adj;
        vector<int> level;
        int n;

      public:
        Dinics(int n) : n(n) { adj.assign(n, {}); }

        void addEdge(int u, int v, int c) {
            adj[u].pb({v, 0, c, (int)adj[v].size()});
            adj[v].pb({u, c, c, (int)adj[u].size() - 1});
        }

        int maxFlow(int s, int t) {
            if (s == t)
                return 0;
            int total = 0, flow;
            while (bfs(s, t)) {
                vector<int> start(n);
                while ((flow = dfs(s, INT_MAX, t, start))) {
                    total += flow;
                }
            }
            return total;
        }

      private:
        bool bfs(int s, int t) {
            level.assign(n, -1);
            level[s] = 0;
            queue<int> q;
            q.push(s);
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                for (auto& e : adj[u]) {
                    if (level[e.v] == -1 && e.flow < e.cap) {
                        level[e.v] = level[u] + 1;
                        q.push(e.v);
                    }
                }
            }
            return level[t] != -1;
        }

        int dfs(int u, int flow, int t, vector<int>& start) {
            if (u == t)
                return flow;
            for (; start[u] < int(adj[u].size()); ++start[u]) {
                Edge& e = adj[u][start[u]];
                if (level[e.v] == level[u] + 1 && e.flow < e.cap) {
                    int newFlow = min(flow, e.cap - e.flow);
                    int augFlow = dfs(e.v, newFlow, t, start);
                    if (augFlow > 0) {
                        e.flow += augFlow;
                        adj[e.v][e.rev].flow -= augFlow;
                        return augFlow;
                    }
                }
            }
            return 0;
        }
    };

snippet segtree Segment Tree 
    int n;
    vector<int> tree;

    void build() {
        for (int i = n - 1; i > 0; --i) {
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
        }
    }

    void modify(int p, int v) {
        tree[p += n] += v;
        for (; p > 1; p >>= 1) {
            tree[p >> 1] = tree[p] + tree[p ^ 1];
        }
    }

    int query(int l, int r) {
        int res = 0;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res += tree[l++];
            if (r & 1) res += tree[--r];
        }
        return res;
    }

snippet ek Edmonds Karp
    class EK {
      private:
        int n;
        vector<vi> cap, adj;

      public:
        EK(int n) : n(n), cap(n, vi(n)), adj(n) {}

        void add(int u, int v, int c) {
            adj[u].pb(v);
            adj[v].pb(u);
            cap[u][v] = c;
        }

        int maxFlow(int s, int t) {
            vi prev(n);
            int tot = 0, f;
            while ((f = bfs(s, t, prev))) {
                tot += f;
                int v = t;
                while (v != s) {
                    int u = prev[v];
                    cap[u][v] -= f;
                    cap[v][u] += f;
                    v = u;
                }
            }
            return tot;
        }

      private:
        int bfs(int s, int t, vi& prev) {
            fill(prev.begin(), prev.end(), -1);
            prev[s] = -2;
            queue<pii> q;
            q.push({s, INT_MAX});
            while (!q.empty()) {
                auto [u, f] = q.front();
                q.pop();
                for (auto v : adj[u]) {
                    if (prev[v] == -1 && cap[u][v] > 0) {
                        int nf = min(f, cap[u][v]);
                        prev[v] = u;
                        if (v == t)
                            return nf;
                        q.push({v, nf});
                    }
                }
            }
            return 0;
        }
    };
